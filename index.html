<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Standing Water – Calm Interactive Ripples</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .water {
      position: relative;
      width: 100%;
      height: 360px;
      border-radius: 16px;
      overflow: hidden;
      background: radial-gradient(120% 80% at 50% -20%, #cfe8ff 0%, #9cc7f7 25%, #5aa9e6 55%, #245c86 100%);
      box-shadow: inset 0 20px 60px rgba(255,255,255,.15), inset 0 -30px 60px rgba(0,0,0,.25);
      touch-action: none;
      user-select: none; -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .water .overlay {
      position: absolute; inset: 0; pointer-events: none;
      background: radial-gradient(120% 90% at 50% -10%, rgba(255,255,255,.35), transparent 40%),
                  radial-gradient(80% 60% at 50% 110%, rgba(0,0,0,.25), transparent 50%);
      mix-blend-mode: soft-light; opacity: .65;
    }
    .water canvas { position: absolute; inset: 0; width: 100%; height: 100%; image-rendering: auto; }
    .water .hint {
      position: absolute; inset: auto 12px 10px 12px;
      color: #eaf3ff; font: 500 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: .75; letter-spacing: .2px; pointer-events: none; text-shadow: 0 1px 0 rgba(0,0,0,.3);
    }
  </style>
</head>
<body style="margin:0; padding:24px; background:#0d1117; color:#e6edf3; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;">
  <h2 style="margin:0 0 12px 2px; font-weight:600;">Standing Water — embeddable demo</h2>
  <div class="water" id="water-demo">
    <canvas></canvas>
    <div class="overlay"></div>
    <div class="hint">tap / click / drag to ripple</div>
  </div>

  <script>
  (function(){
    function initWater($el, opts={}){
      const cfg = Object.assign({
        resolution: 2.2,
        damping: 0.994,
        radius: 8,
        strength: 0.9,
        tint: [80,170,230],
        ambient: 0.48,
        diffuse: 0.52,
        specular: 0.25,
        shininess: 28,
        breeze: 0.0,
      }, opts);

      const canvas = $el.querySelector('canvas') || document.createElement('canvas');
      if (!canvas.parentNode) $el.appendChild(canvas);
      const ctx = canvas.getContext('2d', { alpha: true });
      const DPR = Math.min(devicePixelRatio || 1, 2.5);

      let W=0,H=0, gw=0, gh=0;
      let prev, curr, next;
      let animId = 0, running = true;

      const L = normalize([-0.35, 1.0, 0.25]);
      const V = normalize([0, 1, 0.0]);

      function normalize(v){ const n = Math.hypot(v[0],v[1],v[2])||1; return [v[0]/n, v[1]/n, v[2]/n]; }

      function resize(){
        const rect = $el.getBoundingClientRect();
        W = Math.max(2, Math.floor(rect.width * DPR));
        H = Math.max(2, Math.floor(rect.height * DPR));
        canvas.width = W; canvas.height = H;
        const scale = cfg.resolution;
        gw = Math.max(16, Math.floor(W / scale));
        gh = Math.max(16, Math.floor(H / scale));
        prev = new Float32Array(gw*gh);
        curr = new Float32Array(gw*gh);
        next = new Float32Array(gw*gh);
      }

      function idx(x,y){ return y*gw + x; }

      function step(){
        for (let y=1; y<gh-1; y++){
          const yoff = y*gw;
          for (let x=1; x<gw-1; x++){
            const i = yoff + x;
            const neighbors = curr[i-1] + curr[i+1] + curr[i-gw] + curr[i+gw];
            next[i] = (neighbors * 0.5 - prev[i]) * cfg.damping;
          }
        }
        const tmp = prev; prev = curr; curr = next; next = tmp;
      }

      function render(){
        const w = gw, h = gh;
        const rimg = ctx.createImageData(w, h);
        const data = rimg.data;
        const [rt, gt, bt] = cfg.tint;

        for (let y=1; y<h-1; y++){
          for (let x=1; x<w-1; x++){
            const i = idx(x,y);
            const dx = curr[i+1] - curr[i-1];
            const dy = curr[i+gw] - curr[i-gw];
            let nx = -dx, ny = 1.0, nz = -dy;
            const inv = 1/Math.hypot(nx,ny,nz); nx*=inv; ny*=inv; nz*=inv;

            const ndotl = Math.max(0, nx*L[0] + ny*L[1] + nz*L[2]);
            const diffuse = cfg.diffuse * ndotl;
            const Hx = L[0] + V[0], Hy = L[1] + V[1], Hz = L[2] + V[2];
            const Hn = 1/Math.hypot(Hx,Hy,Hz); const hx=Hx*Hn, hy=Hy*Hn, hz=Hz*Hn;
            const ndoth = Math.max(0, nx*hx + ny*hy + nz*hz);
            const spec = cfg.specular * Math.pow(ndoth, cfg.shininess);
            const ambient = cfg.ambient;

            const depth = 0.5 + Math.max(-0.5, Math.min(0.5, curr[i]*15.0));
            const r = Math.max(0, Math.min(255, (rt*ambient + rt*diffuse) * (1.0 + depth*0.05) + spec*255));
            const g = Math.max(0, Math.min(255, (gt*ambient + gt*diffuse) * (1.0 + depth*0.04) + spec*255));
            const b = Math.max(0, Math.min(255, (bt*ambient + bt*diffuse) * (1.0 + depth*0.06) + spec*255));

            const oi = (y*w + x) * 4;
            data[oi+0] = r|0; data[oi+1] = g|0; data[oi+2] = b|0; data[oi+3] = 255;
          }
        }

        ctx.putImageData(rimg, 0, 0);
        if (w !== W || h !== H){
          ctx.save();
          ctx.imageSmoothingEnabled = true;
          ctx.globalAlpha = 0.98;
          ctx.drawImage(canvas, 0, 0, w, h, 0, 0, W, H);
          ctx.restore();
        }
      }

      let isDown=false, lastT=0;
      $el.addEventListener('pointerdown', e=>{
        isDown = true; lastT = performance.now();
        $el.setPointerCapture(e.pointerId);
        disturbFromEvent(e, 1.0);
      });
      window.addEventListener('pointerup', ()=>{ isDown = false; });
      $el.addEventListener('pointermove', e=>{
        if (!isDown) return;
        const now = performance.now();
        const intensity = Math.min(1.5, 0.4 + Math.hypot(e.movementX||0, e.movementY||0) / 24);
        disturbFromEvent(e, intensity);
        lastT = now;
      }, { passive: true });

      function disturbFromEvent(e, intensity){
        const rect = $el.getBoundingClientRect();
        const px = ((e.clientX - rect.left) / rect.width) * gw;
        const py = ((e.clientY - rect.top) / rect.height) * gh;
        splash(px, py, cfg.radius, -cfg.strength * intensity);
      }

      function splash(cx, cy, r, amp){
        const r2 = r*r;
        const minx = Math.max(1, Math.floor(cx - r));
        const maxx = Math.min(gw-2, Math.ceil(cx + r));
        const miny = Math.max(1, Math.floor(cy - r));
        const maxy = Math.min(gh-2, Math.ceil(cy + r));
        for (let y=miny; y<=maxy; y++){
          for (let x=minx; x<=maxx; x++){
            const dx = x - cx, dy = y - cy;
            const d2 = dx*dx + dy*dy;
            if (d2 <= r2){
              const falloff = 1 - (d2/r2);
              curr[idx(x,y)] += amp * falloff;
            }
          }
        }
      }

      let breezeAcc = 0;
      function maybeBreeze(dt){
        if (cfg.breeze <= 0) return;
        breezeAcc += dt * cfg.breeze;
        while (breezeAcc >= 1){
          breezeAcc -= 1;
          splash( (Math.random()*(gw-4))+2, (Math.random()*(gh-4))+2, 6, -0.6 );
        }
      }

      let lastTime = performance.now();
      function tick(now){
        if (!running) return;
        const dt = Math.min(0.05, (now - lastTime)/1000);
        lastTime = now;
        step();
        maybeBreeze(dt);
        render();
        animId = requestAnimationFrame(tick);
      }

      document.addEventListener('visibilitychange', ()=>{
        running = (document.visibilityState === 'visible');
        if (running && !animId) { lastTime = performance.now(); animId = requestAnimationFrame(tick); }
        if (!running && animId) { cancelAnimationFrame(animId); animId = 0; }
      });

      let resizeId = 0;
      function onResize(){ resize(); }
      window.addEventListener('resize', ()=>{
        clearTimeout(resizeId);
        resizeId = setTimeout(onResize, 100);
      });

      resize();
      lastTime = performance.now();
      animId = requestAnimationFrame(tick);

      return {
        el: $el,
        splash: (x,y,r=8,a=-0.8)=>splash(x*gw, y*gh, r, a),
        setOptions: (patch)=>Object.assign(cfg, patch),
        destroy: ()=>{
          running = false;
          cancelAnimationFrame(animId);
          window.removeEventListener('resize', onResize);
        }
      };
    }
    window.initWater = initWater;
  })();

  const water = initWater(document.getElementById('water-demo'), {
    resolution: 2.2,
    damping: 0.994,
    strength: 0.9,
    breeze: 0.0,
    tint: [80, 170, 230],
    ambient: 0.48, diffuse: 0.52, specular: 0.25, shininess: 28
  });
  </script>

  <hr style="margin:24px 0; border:none; border-top:1px solid #202734">
  <h3 style="margin:8px 0 6px;">How to embed</h3>
  <ol style="margin:0; padding:0 0 0 18px; line-height:1.6; color:#c9d1d9;">
    <li>Copy the <code>initWater</code> script block into your page (or put it in a small JS file and include it).</li>
    <li>Add a container: <code>&lt;div class="water"&gt;&lt;canvas&gt;&lt;/canvas&gt;&lt;div class="overlay"&gt;&lt;/div&gt;&lt;/div&gt;</code></li>
    <li>Call <code>initWater(container, { ...options })</code>. That’s it.</li>
  </ol>
</body>
</html>
