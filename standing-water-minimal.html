<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Standing Water â€“ Minimal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#0d1117; }
    .water {
      position: relative;
      width: 100%;
      height: 420px; /* adjust or set to 100vh if you want full-screen */
      border-radius: 16px;
      overflow: hidden;
      background: radial-gradient(120% 80% at 50% -20%, #cfe8ff 0%, #9cc7f7 25%, #5aa9e6 55%, #245c86 100%);
      box-shadow: inset 0 20px 60px rgba(255,255,255,.15), inset 0 -30px 60px rgba(0,0,0,.25);
      touch-action: none;
      user-select: none; -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .water .overlay {
      position: absolute; inset: 0; pointer-events: none;
      background: radial-gradient(120% 90% at 50% -10%, rgba(255,255,255,.35), transparent 40%),
                  radial-gradient(80% 60% at 50% 110%, rgba(0,0,0,.25), transparent 50%);
      mix-blend-mode: soft-light; opacity: .65;
    }
    .water canvas { position: absolute; inset: 0; width: 100%; height: 100%; image-rendering: auto; }
  </style>
</head>
<body>
  <div class="water" id="water">
    <canvas></canvas>
    <div class="overlay"></div>
  </div>

  <script>
  (function(){
    function initWater($el, opts={}){
      const cfg = Object.assign({
        resolution: 2.2,
        damping: 0.994,
        radius: 8,
        strength: 0.9,
        tint: [80,170,230],
        ambient: 0.48,
        diffuse: 0.52,
        specular: 0.25,
        shininess: 28,
        breeze: 0.0,
      }, opts);

      const canvas = $el.querySelector('canvas') || document.createElement('canvas');
      if (!canvas.parentNode) $el.appendChild(canvas);
      const ctx = canvas.getContext('2d', { alpha: true });
      const DPR = Math.min(devicePixelRatio || 1, 2.5);

      let W=0,H=0, gw=0, gh=0;
      let prev, curr, next;
      let animId = 0, running = true;

      const L = normalize([-0.35, 1.0, 0.25]);
      const V = normalize([0, 1, 0.0]);

      function normalize(v){ const n = Math.hypot(v[0],v[1],v[2])||1; return [v[0]/n, v[1]/n, v[2]/n]; }

      function resize(){
        const rect = $el.getBoundingClientRect();
        W = Math.max(2, Math.floor(rect.width * DPR));
        H = Math.max(2, Math.floor(rect.height * DPR));
        canvas.width = W; canvas.height = H;
        const scale = cfg.resolution;
        gw = Math.max(16, Math.floor(W / scale));
        gh = Math.max(16, Math.floor(H / scale));
        prev = new Float32Array(gw*gh);
        curr = new Float32Array(gw*gh);
        next = new Float32Array(gw*gh);
      }

      function idx(x,y){ return y*gw + x; }

      function step(){
        for (let y=1; y<gh-1; y++){
          const yoff = y*gw;
          for (let x=1; x<gw-1; x++){
            const i = yoff + x;
            const neighbors = curr[i-1] + curr[i+1] + curr[i-gw] + curr[i+gw];
            next[i] = (neighbors * 0.5 - prev[i]) * cfg.damping;
          }
        }
        const tmp = prev; prev = curr; curr = next; next = tmp;
      }

      function render(){
        const w = gw, h = gh;
        const rimg = ctx.createImageData(w, h);
        const data = rimg.data;
        const [rt, gt, bt] = cfg.tint;

        for (let y=1; y<h-1; y++){
          for (let x=1; x<w-1; x++){
            const i = idx(x,y);
            const dx = curr[i+1] - curr[i-1];
            const dy = curr[i+gw] - curr[i-gw];
            let nx = -dx, ny = 1.0, nz = -dy;
            const inv = 1/Math.hypot(nx,ny,nz); nx*=inv; ny*=inv; nz*=inv;

            const ndotl = Math.max(0, nx*L[0] + ny*L[1] + nz*L[2]);
            const diffuse = cfg.diffuse * ndotl;
            const Hx = L[0] + V[0], Hy = L[1] + V[1], Hz = L[2] + V[2];
            const Hn = 1/Math.hypot(Hx,Hy,Hz); const hx=Hx*Hn, hy=Hy*Hn, hz=Hz*Hn;
            const ndoth = Math.max(0, nx*hx + ny*hy + nz*hz);
            const spec = cfg.specular * Math.pow(ndoth, cfg.shininess);
            const ambient = cfg.ambient;

            const depth = 0.5 + Math.max(-0.5, Math.min(0.5, curr[i]*15.0));
            const r = Math.max(0, Math.min(255, (rt*ambient + rt*diffuse) * (1.0 + depth*0.05) + spec*255));
            const g = Math.max(0, Math.min(255, (gt*ambient + gt*diffuse) * (1.0 + depth*0.04) + spec*255));
            const b = Math.max(0, Math.min(255, (bt*ambient + bt*diffuse) * (1.0 + depth*0.06) + spec*255));

            const oi = (y*w + x) * 4;
            data[oi+0] = r|0; data[oi+1] = g|0; data[oi+2] = b|0; data[oi+3] = 255;
          }
        }

        ctx.putImageData(rimg, 0, 0);
        if (w !== W || h !== H){
          ctx.save();
          ctx.imageSmoothingEnabled = true;
          ctx.globalAlpha = 0.98;
          ctx.drawImage(canvas, 0, 0, w, h, 0, 0, W, H);
          ctx.restore();
        }
      }

      let isDown=false;
      $el.addEventListener('pointerdown', e=>{
        isDown = true;
        $el.setPointerCapture(e.pointerId);
        disturbFromEvent(e, 1.0);
      });
      window.addEventListener('pointerup', ()=>{ isDown = false; });
      $el.addEventListener('pointermove', e=>{
        if (!isDown) return;
        const intensity = Math.min(1.5, 0.4 + Math.hypot(e.movementX||0, e.movementY||0) / 24);
        disturbFromEvent(e, intensity);
      }, { passive: true });

      function disturbFromEvent(e, intensity){
        const rect = $el.getBoundingClientRect();
        const px = ((e.clientX - rect.left) / rect.width) * gw;
        const py = ((e.clientY - rect.top) / rect.height) * gh;
        splash(px, py, cfg.radius, -cfg.strength * intensity);
      }

      function splash(cx, cy, r, amp){
        const r2 = r*r;
        const minx = Math.max(1, Math.floor(cx - r));
        const maxx = Math.min(gw-2, Math.ceil(cx + r));
        const miny = Math.max(1, Math.floor(cy - r));
        const maxy = Math.min(gh-2, Math.ceil(cy + r));
        for (let y=miny; y<=maxy; y++){
          for (let x=minx; x<=maxx; x++){
            const dx = x - cx, dy = y - cy;
            const d2 = dx*dx + dy*dy;
            if (d2 <= r2){
              const falloff = 1 - (d2/r2);
              curr[idx(x,y)] += amp * falloff;
            }
          }
        }
      }

      // gentle auto-pause on hidden tab
      document.addEventListener('visibilitychange', ()=>{
        running = (document.visibilityState === 'visible');
        if (running && !animId) animId = requestAnimationFrame(tick);
        if (!running && animId) { cancelAnimationFrame(animId); animId = 0; }
      });

      // loop
      function tick(){
        if (!running) return;
        step();
        render();
        animId = requestAnimationFrame(tick);
      }

      // resize
      let resizeId = 0;
      function onResize(){ resize(); }
      window.addEventListener('resize', ()=>{
        clearTimeout(resizeId); resizeId = setTimeout(onResize, 100);
      });

      resize();
      animId = requestAnimationFrame(tick);

      return { setOptions: (patch)=>Object.assign(cfg, patch) };
    }

    window.initWater = initWater;
  })();

  // init
  initWater(document.getElementById('water'), {
    resolution: 2.2,
    damping: 0.994,
    strength: 0.9,
    breeze: 0.0,
    tint: [80,170,230],
    ambient: 0.48, diffuse: 0.52, specular: 0.25, shininess: 28
  });
  </script>
</body>
</html>
